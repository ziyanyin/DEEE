### Define weave class and corresponding methods
#' @include AA_sampleVectorClass.R
NULL

#' Weave function.
#'
#' \code{weave} defines and produces a weave object. The difference between weave and
#' GroupWeave is their way to apply FUN. In weave, FUN is applied to every single column;
#' while in GroupWeave, FUN takes the whole columns in a group as argument.
#' See also \code{\link{MedWeave}}, in which FUN = ``median'', interval = c(0, 1) and ifeq
#' = ``>''.
#'
#' @param dataset A sampleVector object containing data and other information.
#' @param degree A integer specifying the degree of the polynomail logistic regression.
#' @param FUN Function used in weave.
#' @param interval A value between 0 and 1 to restrict the rankit used.
#' @param ifeq Use >= or >?
#' @return A weave object is returned, which is a list containing fitY as the fitted response values, selCol as the
#' @examples
#' data(GCwPADataA)
#' testset = sampleVector(GCwPADataA, selCol = list(1:5, 11:15, 21:25), labels = c("E", "R", "T"), dataType = "Example")
#' medw1 = weave(dataset = testset, degree = 6, FUN = "median", interval = c(0, 1))
#' @export
weave = function(dataset = testset, degree = 4, FUN = "median", interval = c(0, 1), ifeq = FALSE)
{
    if(!is(dataset, "sampleVector")) stop("Invalid dataset input")
    mydata = dataset$data

    nweave = dataset$nCol
    nrow = dataset$nRow

    newX = MatRankit(mydata)
    myOd = Cpp_order(newX) + 1

    selInd = which((newX <= max(interval)) & (newX >= min(interval)))
    newX = newX[selInd]
    polyx = poly(newX, degree = degree, raw = TRUE)

    fitY = lapply(1:nweave, function(idcol) {
        cat(" ", idcol, "\t out of ", nweave, "\n")
        y = sapply(1:nrow, function(i) as.numeric(get(ifelse(ifeq, ">=", ">"))(mydata[i, idcol], match.fun(FUN)(mydata[i, -idcol]))))
        newY = y[selInd]
        predY = predict(glm(newY ~ polyx, family = "binomial"), type = "response")
        predY
        })
    names(fitY) = 1:nweave

    res = list(fitY = fitY, selCol = dataset$selCol, labels = dataset$labels, dataType = dataset$dataType)
    res$order = myOd
    res$nweave = nweave
    res$rankit = newX
    res$interval = interval
    res$Function = FUN
    res$ifeq = ifelse(ifeq, ">=", ">")
    res$colInd = dataset$colInd
    class(res) = "weave"
    return(res)
}

#' Produce a weave object.
#'
#' This function use ``median'' to produce a weave object, with ``>'' and interval (0, 1), which is much faster.
#'
#' @param dataset A sampleVector object containing data and other information.
#' @param degree A degree-th polynomail logistic regression is fitted.
#' @return A weave object.
#' @examples
#' data(GCwPADataA)
#' testset = sampleVector(GCwPADataA, selCol = list(1:5, 11:15, 21:25), labels = c("E", "R", "T"), dataType = "Example")
#' m1 = MedWeave(dataset = testset, degree = 6)
#' @export
MedWeave = function(dataset = testset, degree = 4)
{
    if(!is(dataset, "sampleVector")) stop("Invalid dataset input")
    mydata = dataset$data

    nweave = dataset$nCol
    nrow = dataset$nRow
    newX = MatRankit(mydata)
    myOd = Cpp_order(newX) + 1

	res = list()
	polyx = poly(newX, degree = degree, raw = TRUE)
	fitY = lapply(1:nweave, function(ref) {
		cat(" ", ref, "\t out of ", nweave, "\n")
		y = MedWVY(mydata, ref - 1)
		predict(glm(y ~ polyx, family = "binomial"), type = "response")
	})

	names(fitY) = 1:nweave

	res = list(fitY = fitY, selCol = dataset$selCol, labels = dataset$labels, dataType = dataset$dataType)
	res$order = myOd
	res$nweave = nweave
	res$rankit = newX
	res$interval = c(0, 1)
    res$Function = "median"
    res$ifeq = ">"
    res$colInd = dataset$colInd
    class(res) = "weave"
    return(res)
}

#' Print method of weave class.
#'
#' @param obj A weave object.
#' @export
print.weave = function(obj)
{
    cat("This is a weave object.\n")
    cat("Data type: ", obj$dataType, ". Function:", obj$Function, ",", obj$ifeq, ". ")
	cat("Rankit interval: (", paste0(obj$interval, collapse = ", "), "). \n")
    cat(paste0("Total Weaves: ", obj$nweave, " in ", length(obj$labels), " Groups."), "\n")
    cat(paste0("Contains: ", paste0(obj$labels, collapse = ", "), "."))
}

#' The plot method for a weave object.
#'
#' @param obj A weave object.
#' @param indSet The index set specifying weaves in which groups to be plot.
#' @param legPar A list of legend parameters.
#' @param graPar A list of global graphics parameters.
#' @param plotPar A list of background (including main title) parameters.
#' @return NULL
#' @examples
#' data(GCwPADataA)
#' testset = sampleVector(GCwPADataA, selCol = list(1:5, 11:15, 21:25), labels = c("E", "R", "T"))
#' medw1 = MedWeave(dataset = testset, degree = 6)
#' plot(medw1, indSet = 1:2, legPar = list(cex = 1, ncol = 1), plotPar = list(main = "Example"))
#' @export
plot.weave = function(obj, indSet = 1:obj$nweave, legPar = list(cex = 0.6, ncol = 3), graPar = list(), plotPar = list())
{
    parDe = par(graPar)
    on.exit(par(parDe))

    do.call("plot", paraMerge(list(x = obj$interval, y = c(0.5, 0.5), xlab = "Rankit", ylab = paste0("Pr(sample", obj$ifeq, obj$Function, "(other samples))"), xlim = obj$interval, ylim = c(0, 1), type = "l", col = "gray", lty = 10), plotPar))

	fitY = obj$fitY
    x = obj$rankit
    int = obj$interval
	myOd = obj$order

	newX = x[myOd]
	refset = rep(1:length(obj$colInd), sapply(obj$colInd, length))
	sapply(indSet, function(i) {
		lines(x = newX, y = fitY[[i]][myOd], col = refset[i])
		})
    grid()

    if(is.null(legPar$ifleg) || legPar$ifleg)
    {
        legLoc = NULL
        if(is.null(legPar$x)) legLoc = c(mean(int), 1.04)
        legPar$ifleg = NULL
        do.call("legend", paraMerge(list(x = legLoc[1], y = legLoc[2], legend = obj$labels, lty = 1, col = 1:length(obj$labels)), legPar))
    }

    invisible()
}
